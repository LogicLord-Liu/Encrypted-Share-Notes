---
import Layout from "../../layouts/Layout.astro";

// 在服务器端获取路由参数
const { id } = Astro.params;

// 这里的服务器端变量只是占位符，实际加载由客户端 JS 处理
---

<Layout title="查看笔记 - Enclosed">
  <main class="flex flex-col items-center justify-center min-h-screen">
    <div class="bg-white p-8 rounded-lg shadow-lg w-full max-w-2xl text-center">
      <h1 class="text-3xl font-bold mb-6 text-gray-800">笔记内容</h1>

      <div id="note-display-area">
        <p class="text-gray-600">正在加载笔记...</p>
      </div>

      <div id="password-form-container" class="hidden"></div>

      <a href="/" class="mt-8 inline-block text-sky-600 hover:underline"
        >返回首页</a
      >
    </div>
  </main>
</Layout>

<script is:inline>
  if (typeof window !== "undefined") {
    const url = new URL(window.location.href);
    const noteId = url.pathname.split("/").pop();
    const noteDisplayArea = document.getElementById("note-display-area");
    const passwordFormContainer = document.getElementById(
      "password-form-container"
    );

    function displayError(message) {
      if (!noteDisplayArea) return;
      noteDisplayArea.innerHTML = `
        <div class="text-red-500 font-medium text-center">加载笔记失败</div>
        <p class="text-red-500 text-center mt-2">${message}</p>
      `;
    }

    function displayNote(note) {
      if (!noteDisplayArea) return;

      const markdownContent = note.content;

      noteDisplayArea.innerHTML = `
        <article class="prose lg:prose-lg mx-auto text-left break-all whitespace-pre-wrap">
          <p>${markdownContent}</p>
        </article>
        <div class="mt-8 pt-4 border-t border-gray-200 text-center text-sm text-gray-500">
          <p>创建于: ${new Date(note.createdAt).toLocaleString()}</p>
          <p>过期时间: ${note.expiration}</p>
          ${
        note.deleteAfterReading
          ? '<p class="text-red-500">此笔记将在首次阅读后被删除。</p>'
          : ""
      }
          ${
        note.files && note.files.length > 0
          ? `
              <div class="mt-4">
                <p class="font-medium">附件:</p>
                <ul class="list-disc list-inside mt-1 mx-auto text-left w-fit">
                  ${note.files
              .map(
                (file) =>
                  `<li>${file.name} (${(file.size / 1024).toFixed(1)} KB)</li>`
              )
              .join("")}
                </ul>
              </div>
              `
          : ""
      }
        </div>
      `;
      // 如果笔记显示成功，清除密码表单
      if (passwordFormContainer) {
        passwordFormContainer.innerHTML = "";
        passwordFormContainer.classList.add("hidden");
      }
    }

    async function decryptNote(note) {
      // ... (解密逻辑保持不变)
      if (!note.key || !note.iv || !note.content) {
        throw new Error("笔记数据不完整，无法解密。");
      }

      const keyBase64 = note.key;
      const ivBase64 = note.iv;
      const encryptedContentBase64 = note.content;
      const notePassword = note.password || null; // 将 Base64 字符串转换为 ArrayBuffer

      const keyBuffer = Uint8Array.from(atob(keyBase64), (c) =>
        c.charCodeAt(0)
      );
      const ivBuffer = Uint8Array.from(atob(ivBase64), (c) => c.charCodeAt(0));
      const encryptedContentBuffer = Uint8Array.from(
        atob(encryptedContentBase64),
        (c) => c.charCodeAt(0)
      );

      let finalKeyBuffer = keyBuffer; // 如果有密码，先用密码解密笔记密钥

      if (note.hasPassword) {
        if (!notePassword) {
          throw new Error("此笔记受密码保护，请输入密码。");
        }

        const encoder = new TextEncoder();
        const passwordKey = await window.crypto.subtle.importKey(
          "raw",
          encoder.encode(notePassword),
          { name: "PBKDF2" },
          false,
          ["deriveKey"]
        );

        const derivedPasswordKey = await window.crypto.subtle.deriveKey(
          {
            name: "PBKDF2",
            salt: ivBuffer,
            iterations: 100000,
            hash: "SHA-256",
          },
          passwordKey,
          { name: "AES-GCM", length: 256 },
          false,
          ["decrypt"]
        );

        try {
          finalKeyBuffer = await window.crypto.subtle.decrypt(
            { name: "AES-GCM", iv: ivBuffer },
            derivedPasswordKey,
            keyBuffer
          );
        } catch (err) {
          console.error("解密密钥失败:", err);
          throw new Error("密码错误或解密密钥失败。");
        }
      } // 使用最终的密钥解密笔记内容

      const cryptoKey = await window.crypto.subtle.importKey(
        "raw",
        finalKeyBuffer,
        { name: "AES-GCM", length: 256 },
        true,
        ["decrypt"]
      );

      const decryptedContent = await window.crypto.subtle.decrypt(
        {
          name: "AES-GCM",
          iv: ivBuffer,
        },
        cryptoKey,
        encryptedContentBuffer
      );

      const decoder = new TextDecoder();
      return decoder.decode(decryptedContent);
    }

    function renderPasswordForm(note) {
      if (!passwordFormContainer) return;

      noteDisplayArea.innerHTML =
        '<p class="text-gray-600">此笔记受密码保护。</p>';

      passwordFormContainer.innerHTML = `
        <div class="max-w-md mx-auto bg-white p-8 rounded-lg shadow-md text-center">
          <h2 class="text-2xl font-bold mb-4">请输入密码</h2>
          <form id="password-form" class="space-y-4">
            <input 
              id="note-password-input"
              type="password"
              placeholder="请输入密码"
              class="w-full px-4 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500"
              required
            />
            <button 
              type="submit"
              class="w-full bg-sky-500 text-white py-2 rounded-md hover:bg-sky-600 transition duration-300"
            >
              解锁笔记
            </button>
          </form>
        </div>
      `;
      passwordFormContainer.classList.remove("hidden");

      const passwordForm = document.getElementById("password-form");
      const passwordInput = document.getElementById("note-password-input");

      if (passwordForm && passwordInput) {
        passwordForm.addEventListener("submit", async (e) => {
          e.preventDefault();
          const password = passwordInput.value;
          passwordInput.classList.remove("border-red-500");
          passwordInput.placeholder = "请输入密码";

          try {
            const decryptedContent = await decryptNote({ ...note, password });
            displayNote({ ...note, content: decryptedContent });
          } catch (err) {
            passwordInput.classList.add("border-red-500");
            passwordInput.placeholder = "密码错误，请重试";
            passwordInput.value = "";
            console.error("解密失败:", err);
          }
        });
      }
    }

    async function loadNote() {
      if (!noteId) {
        displayError("无效的笔记链接。");
        return;
      }

      try {
        const response = await fetch(`/api/note/${noteId}`);
        console.log(`GET /api/note/${noteId} status: ${response.status}`);

        if (!response.ok) {
          if (response.status === 404) {
            throw new Error("笔记未找到或已过期。");
          } else {
            throw new Error("加载笔记时发生网络错误。");
          }
        }

        const foundNote = await response.json();

        // 关键逻辑：如果后端返回的数据表示有密码，则显示密码表单
        if (foundNote.hasPassword) {
          renderPasswordForm(foundNote);
        } else {
          const decryptedContent = await decryptNote(foundNote);
          displayNote({ ...foundNote, content: decryptedContent });
        }
      } catch (err) {
        console.error("加载笔记失败:", err);
        displayError(err.message);
      }
    } // 页面加载时执行

    document.addEventListener("DOMContentLoaded", () => {
      loadNote();
    });
  }
</script>
