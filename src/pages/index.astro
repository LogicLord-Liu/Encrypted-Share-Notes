---
// src/pages/index.astro
import Layout from "../layouts/Layout.astro";

import Header from "../components/Header";
import Footer from "../components/Footer";
import MainContent from "../components/NoteEditor.astro";

import qrcode from "qrcode";
---

<Layout title="安全分享 - Enclosed">
  <Header client:load />

  <MainContent client:load />

  <Footer client:load />
</Layout>

<script is:inline>
  // 获取 DOM 元素
  const noteContentInput = document.getElementById("note-content");
  const notePasswordInput = document.getElementById("note-password");
  const togglePasswordButton = document.getElementById("toggle-password");
  const eyeOpenIcon = document.getElementById("eye-open");
  const eyeClosedIcon = document.getElementById("eye-closed");
  const generatePasswordButton = document.getElementById("generate-password");
  const expirationOptionsContainer =
    document.getElementById("expiration-options");
  const deleteAfterReadingCheckbox = document.getElementById(
    "delete-after-reading"
  );
  const createNoteButton = document.getElementById("create-note-button");

  const passwordStrengthText = document.getElementById(
    "password-strength-text"
  );
  const passwordStrengthFill = document.getElementById(
    "password-strength-fill"
  );

  const NOTES_STORAGE_KEY = "enclosed_notes_data";

  // === 新增：成功弹窗相关的 DOM 元素 ===
  const successModal = document.getElementById("success-modal");
  const successModalContent = document.getElementById("success-modal-content");
  const encryptedLinkDisplay = document.getElementById(
    "encrypted-link-display"
  );
  const copyLinkButton = document.getElementById("copy-link-button");
  const copyFeedback = document.getElementById("copy-feedback");
  const qrcodeContainer = document.getElementById("qrcode-container");
  const qrcodeCanvas = document.getElementById("qrcode-canvas"); // 虽然 qrcode.js 直接操作容器，但获取 canvas ID 可能有用
  const closeModalButton = document.getElementById("close-modal-button");
  const errorMessageContainer = document.getElementById("error-message");

  // 状态变量
  let showPassword = false;
  let selectedExpiration = "1hour"; // 默认值
  let uploadedFiles = [];

  function generateUniqueId() {
    return (
      Math.random().toString(36).substring(2, 15) +
      Math.random().toString(36).substring(2, 15)
    );
  }

  // 定义密码强度标签和颜色
  const strengthLabels = ["非常弱", "弱", "中等", "强", "非常强"];
  const strengthColors = [
    "bg-red-500", // score 0: Very Weak
    "bg-orange-400", // score 1: Weak
    "bg-yellow-400", // score 2: Medium
    "bg-green-400", // score 3: Strong
    "bg-green-600", // score 4: Very Strong
  ];

  // 监听密码输入框的 input 事件
  notePasswordInput.addEventListener("input", () => {
    const value = notePasswordInput.value;
    const result = zxcvbn(value); // 评估密码强度

    // 更新密码强度文本
    passwordStrengthText.textContent = value
      ? `密码强度：${strengthLabels[result.score]}`
      : "";

    // 移除所有旧的颜色类，防止累积
    strengthColors.forEach((c) => passwordStrengthFill.classList.remove(c));

    // 根据密码强度设置进度条的颜色和宽度
    if (value) {
      passwordStrengthFill.classList.add(strengthColors[result.score]);
      // 强度条宽度是总宽度的 (score + 1) * 20%
      passwordStrengthFill.style.width = `${(result.score + 1) * 20}%`;
    } else {
      // 密码为空时，清空进度条
      passwordStrengthFill.style.width = "0%";
    }
  });

  // 页面加载时，如果密码框有值（例如浏览器自动填充），也触发一次强度检测
  if (notePasswordInput.value) {
    const event = new Event("input");
    notePasswordInput.dispatchEvent(event);
  }

  // 密码显示/隐藏
  togglePasswordButton.addEventListener("click", () => {
    showPassword = !showPassword;
    notePasswordInput.type = showPassword ? "text" : "password";
    eyeOpenIcon.classList.toggle("hidden", !showPassword);
    eyeClosedIcon.classList.toggle("hidden", showPassword);
  });

  // 生成密码
  generatePasswordButton.addEventListener("click", () => {
    const chars =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+";
    let password = "";
    for (let i = 0; i < 15; i++) {
      password += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    notePasswordInput.value = password;

    const event = new Event("input", {
      bubbles: true, // 事件是否冒泡
      cancelable: true, // 事件是否可以取消
    });
    notePasswordInput.dispatchEvent(event);
  });

  // 过期时间选择
  expirationOptionsContainer.addEventListener("click", (event) => {
    const targetButton = event.target.closest("button[data-value]");
    if (targetButton) {
      // 移除所有按钮的选中样式
      expirationOptionsContainer.querySelectorAll("button").forEach((btn) => {
        btn.classList.remove("bg-sky-500/60", "text-white");
        btn.classList.add("bg-gray-100", "text-gray-700", "hover:bg-gray-200");
      });
      // 添加选中按钮的样式
      targetButton.classList.add("bg-sky-500/60", "text-white");
      targetButton.classList.remove(
        "bg-gray-100",
        "text-gray-700",
        "hover:bg-gray-200"
      );
      selectedExpiration = targetButton.dataset.value;
    }
  });

  // 启用/禁用创建笔记按钮
  noteContentInput.addEventListener("input", () => {
    createNoteButton.disabled = noteContentInput.value.trim() === "";
  });
  // 初始禁用状态
  createNoteButton.disabled = noteContentInput.value.trim() === "";

  function waitForGlobal(variableName, timeout = 5000) {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      const checkInterval = setInterval(() => {
        if (
          typeof window[variableName] !== "undefined" &&
          window[variableName] !== null
        ) {
          clearInterval(checkInterval);
          resolve(window[variableName]);
        } else if (Date.now() - startTime > timeout) {
          clearInterval(checkInterval);
          reject(new Error(`${variableName} 未能在 ${timeout}ms 内加载。`));
        }
      }, 50); // 每50毫秒检查一次
    });
  }

  // 创建笔记逻辑
  createNoteButton.addEventListener("click", async () => {
    console.log("创建笔记按钮被点击了！");

    const noteContent = noteContentInput.value.trim();
    if (!noteContent) {
      alert("笔记内容不能为空！");
      return;
    }

    if (!errorMessageContainer.classList.contains("hidden")) {
      alert("请解决文件上传错误后重试。");
      return;
    }

    const notePassword = notePasswordInput.value;
    const deleteAfterReading = deleteAfterReadingCheckbox.checked;

    const newNote = {
      id: generateUniqueId(), // 使用生成的唯一ID
      content: noteContent,
      password: notePassword, // 密码明文，实际应用中应该哈希处理
      expiration: selectedExpiration,
      deleteAfterReading: deleteAfterReading,
      files: uploadedFiles.map((f) => ({
        // 仅保存文件元数据，实际文件内容无法在 localStorage 中直接保存
        name: f.name,
        size: f.size,
        type: f.type,
        // 实际应用中这里会是文件在服务器上的路径或ID
      })),
      createdAt: new Date().toISOString(), // 添加创建时间
      // 其他字段，如查看次数，实际应用中后端处理
    };

    let notes = JSON.parse(localStorage.getItem(NOTES_STORAGE_KEY) || "[]");
    notes.push(newNote);
    localStorage.setItem(NOTES_STORAGE_KEY, JSON.stringify(notes));

    console.log("模拟保存的笔记数据:", newNote);

    console.log("创建笔记：", {
      content: noteContent,
      password: notePassword,
      expiration: selectedExpiration,
      deleteAfterReading: deleteAfterReading,
      files: uploadedFiles.map((f) => ({
        name: f.name,
        size: f.size,
        type: f.type,
      })),
    });

    // 模拟成功创建笔记，获取一个虚拟的笔记ID
    const dummyNoteId = generateUniqueId();
    // 模拟的加密链接 (根据你的实际应用修改)
    const encryptedLink = `${window.location.origin}/note/${dummyNoteId}`; // 示例链接

    // 清空表单
    noteContentInput.value = "";
    notePasswordInput.value = "";
    deleteAfterReadingCheckbox.checked = false;
    uploadedFiles = [];
    fileInput.value = "";
    uploadArea.classList.add("hidden");
    fileList.innerHTML = ""; // 清空文件列表

    // 重置过期时间选择按钮样式
    expirationOptionsContainer.querySelectorAll("button").forEach((btn) => {
      btn.classList.remove("bg-sky-500/60", "text-white");
      btn.classList.add("bg-gray-100", "text-gray-700", "hover:bg-gray-200");
      if (btn.dataset.value === "1hour") {
        btn.classList.add("bg-sky-500/60", "text-white");
        btn.classList.remove(
          "bg-gray-100",
          "text-gray-700",
          "hover:bg-gray-200"
        );
      }
    });
    selectedExpiration = "1hour";
    createNoteButton.disabled = true;

    if (!successModal || !successModalContent) {
      console.error(
        "successModal 或 successModalContent 元素未定义！请检查 HTML ID 和 JS 获取代码。"
      );
      alert("弹窗加载失败，请刷新页面。");
      return;
    }

    // === 显示成功弹窗 ===
    encryptedLinkDisplay.value = encryptedLink;

    // 确保 canvas 容器是空的，防止重复渲染
    qrcodeCanvas
      .getContext("2d")
      .clearRect(0, 0, qrcodeCanvas.width, qrcodeCanvas.height);

    // 使用新的 qrcode.es 库生成二维码
    try {
      console.log("等待 QRCodeGenerator 加载...");
      const QRCodeGeneratorObj = await waitForGlobal("QRCodeGenerator", 10000); // 等待获取到的是 qrcode 对象
      console.log("QRCodeGenerator 已加载，类型:", typeof QRCodeGeneratorObj);

      // 现在我们知道 QRCodeGeneratorObj 是一个对象
      // 它的 toCanvas 方法位于 QRCodeGeneratorObj.toCanvas
      if (typeof QRCodeGeneratorObj.toCanvas === "function") {
        // <--- 更改这里的检查：检查 toCanvas 是否是函数
        await QRCodeGeneratorObj.toCanvas(qrcodeCanvas, encryptedLink, {
          // <--- 更改这里的调用：通过对象调用方法
          width: 128,
          errorCorrectionLevel: "H",
        });
        console.log("二维码生成成功!");

        if (!qrcodeCanvas.dataset.listenerAdded) {
          // 使用 dataset 属性标记是否已添加监听器
          qrcodeCanvas.style.cursor = "pointer"; // 鼠标悬停时显示手型光标
          qrcodeCanvas.addEventListener("click", () => {
            encryptedLinkDisplay.select();
            encryptedLinkDisplay.setSelectionRange(0, 99999);
            navigator.clipboard
              .writeText(encryptedLinkDisplay.value)
              .then(() => {
                // 暂时使用 copyFeedback 来显示二维码复制成功
                copyFeedback.textContent = "二维码链接已复制！"; // 更新提示文本
                copyFeedback.classList.remove("hidden");
                setTimeout(() => {
                  copyFeedback.classList.add("hidden");
                  copyFeedback.textContent = "链接已复制！"; // 恢复原始提示文本
                }, 2000);
              })
              .catch((err) => {
                console.error("通过点击二维码复制失败:", err);
                alert("复制链接失败，请手动复制。");
              });
          });
          qrcodeCanvas.dataset.listenerAdded = "true"; // 标记已添加
        }
      } else {
        console.error(
          "QRCodeGenerator 对象中未找到 toCanvas 方法，或 toCanvas 不是一个函数。"
        );
        qrcodeContainer.textContent = "二维码生成失败。";
      }
    } catch (error) {
      console.error("二维码库加载或生成失败:", error);
      qrcodeContainer.textContent = "二维码生成失败。";
      alert("二维码生成失败：" + error.message);
    }

    // 显示弹窗并应用动画类 (保持不变)
    successModal.classList.remove("hidden");
    console.log(
      "已移除 hidden 类。successModal.classList:",
      successModal.classList
    );
    void successModal.offsetWidth;
    console.log("已强制回流。");

    console.log("准备添加透明度/缩放类...");
    successModal.classList.add("opacity-100");
    successModalContent.classList.remove("scale-95", "opacity-0");
    successModalContent.classList.add("scale-100", "opacity-100");
    console.log(
      "已添加透明度/缩放类。successModalContent.classList:",
      successModalContent.classList
    );

    console.log("--- 弹窗显示逻辑完成 ---");
  });

  // === 弹窗功能逻辑 ===

  // 复制链接功能
  copyLinkButton.addEventListener("click", () => {
    encryptedLinkDisplay.select(); // 选中输入框中的文本
    encryptedLinkDisplay.setSelectionRange(0, 99999); // 适用于移动设备
    navigator.clipboard
      .writeText(encryptedLinkDisplay.value)
      .then(() => {
        copyFeedback.classList.remove("hidden");
        setTimeout(() => {
          copyFeedback.classList.add("hidden");
        }, 2000); // 2秒后隐藏提示
      })
      .catch((err) => {
        console.error("复制失败:", err);
        alert("复制链接失败，请手动复制。");
      });
  });
  encryptedLinkDisplay.addEventListener("click", () => {
    encryptedLinkDisplay.select();
    encryptedLinkDisplay.setSelectionRange(0, 99999);
    navigator.clipboard
      .writeText(encryptedLinkDisplay.value)
      .then(() => {
        copyFeedback.textContent = "链接已复制！";
        copyFeedback.classList.remove("hidden");
        setTimeout(() => {
          copyFeedback.classList.add("hidden");
        }, 2000);
      })
      .catch((err) => {
        console.error("点击输入框复制失败:", err);
        alert("复制链接失败，请手动复制。");
      });
  });

  // 关闭弹窗功能
  closeModalButton.addEventListener("click", () => {
    successModal.classList.remove("opacity-100");
    successModalContent.classList.remove("scale-100", "opacity-100");
    successModalContent.classList.add("scale-95", "opacity-0");
    setTimeout(() => {
      successModal.classList.add("hidden");
    }, 300); // 等待动画完成再隐藏
  });

  // 点击弹窗背景也可以关闭 (可选)
  successModal.addEventListener("click", (event) => {
    if (event.target === successModal) {
      closeModalButton.click(); // 调用关闭按钮的点击事件
    }
  });

  const uploadBtn = document.getElementById("upload-btn");
  const fileInput = document.getElementById("file-input");
  const uploadArea = document.getElementById("upload-area");
  const fileList = document.getElementById("file-list");
  const errorMessage = document.getElementById("error-message");
  const errorText = document.getElementById("error-text");

  const MAX_SIZE_MB = 10;
  const MAX_FILE_SIZE = MAX_SIZE_MB * 1024 * 1024;

  uploadBtn.addEventListener("click", () => {
    fileInput.click();
  });

  fileInput.addEventListener("change", () => {
    const files = fileInput.files;
    fileList.innerHTML = "";
    let hasError = false;

    for (const file of files) {
      console.log(`文件：${file.name}, 大小：${file.size / (1024 * 1024)} MB`);

      if (file.size > MAX_FILE_SIZE) {
        hasError = true;
        errorText.textContent = `文件 "${file.name}" 超过 ${MAX_SIZE_MB}MB 大小限制`;
        errorMessage.classList.remove("hidden");
      } else {
        const li = document.createElement("li");
        li.textContent = `${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
        fileList.appendChild(li);
      }
    }

    if (!hasError) {
      errorMessage.classList.add("hidden");
    }

    if (files.length > 0) {
      uploadArea.classList.remove("hidden");
    }
  });
</script>
