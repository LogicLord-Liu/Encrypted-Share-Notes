---
// src/pages/index.astro
import Layout from "../layouts/Layout.astro";
import Header from "../components/Header";
import Footer from "../components/Footer";
import MainContent from "../components/NoteEditor.astro";
import fileIcons from "../data/fileIcons.json";
---

<Layout title="安全分享 - Transcrypt">
  <Header client:load />
  <MainContent client:load />
  <Footer client:load />
</Layout>

<script is:inline>
  if (typeof window !== "undefined") {
    //TODO: 文件ICONS
    //const fileIcons = JSON.parse("{{ JSON.stringify(fileIcons) }}");
    // 全局状态变量
    let showPassword = false;
    let selectedExpiration = "1hour";
    let uploadedFiles = [];
    const MAX_SIZE_MB = 10;
    const MAX_FILE_SIZE = MAX_SIZE_MB * 1024 * 1024;
    const NOTES_STORAGE_KEY = "enclosed_notes_data";
    const strengthLabels = ["非常弱", "弱", "中等", "强", "非常强"];
    const strengthColors = [
      "bg-red-500",
      "bg-orange-400",
      "bg-yellow-400",
      "bg-green-400",
      "bg-green-600",
    ]; // DOM 元素引用

    const dom = {
      noteContentInput: document.getElementById("note-content"),
      notePasswordInput: document.getElementById("note-password"),
      togglePasswordButton: document.getElementById("toggle-password"),
      eyeOpenIcon: document.getElementById("eye-open"),
      eyeClosedIcon: document.getElementById("eye-closed"),
      generatePasswordButton: document.getElementById("generate-password"),
      expirationOptionsContainer: document.getElementById("expiration-options"),
      neverExpiresCheckbox: document.getElementById("never-expires"),
      deleteAfterReadingCheckbox: document.getElementById(
        "delete-after-reading"
      ),
      createNoteButton: document.getElementById("create-note-button"),
      passwordStrengthText: document.getElementById("password-strength-text"),
      passwordStrengthFill: document.getElementById("password-strength-fill"),
      successModal: document.getElementById("success-modal"),
      successModalContent: document.getElementById("success-modal-content"),
      encryptedLinkDisplay: document.getElementById("encrypted-link-display"),
      copyLinkButton: document.getElementById("copy-link-button"),
      copyFeedback: document.getElementById("copy-feedback"),
      qrcodeContainer: document.getElementById("qrcode-container"),
      qrcodeCanvas: document.getElementById("qrcode-canvas"),
      closeModalButton: document.getElementById("close-modal-button"),
      errorMessageContainer: document.getElementById("error-message"),
      uploadBtn: document.getElementById("upload-btn"),
      fileInput: document.getElementById("file-input"),
      uploadArea: document.getElementById("upload-area"),
      fileList: document.getElementById("file-list"),
      errorText: document.getElementById("error-text"),
    }; // --- 辅助函数 ---

    function generateUniqueId() {
      return (
        Math.random().toString(36).substring(2, 15) +
        Math.random().toString(36).substring(2, 15)
      );
    }

    function formatBytes(bytes, decimals = 1) {
      if (bytes === 0) return "0 Bytes";
      const k = 1024;
      const dm = decimals < 0 ? 0 : decimals;
      const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + " " + sizes[i];
    }

    function waitForGlobal(variableName, timeout = 5000) {
      return new Promise((resolve, reject) => {
        const startTime = Date.now();
        const checkInterval = setInterval(() => {
          if (
            typeof window[variableName] !== "undefined" &&
            window[variableName] !== null
          ) {
            clearInterval(checkInterval);
            resolve(window[variableName]);
          } else if (Date.now() - startTime > timeout) {
            clearInterval(checkInterval);
            reject(new Error(`${variableName} 未能在 ${timeout}ms 内加载。`));
          }
        }, 50);
      });
    } // --- 文件上传和删除逻辑 ---

    function renderFileList() {
      if (!dom.fileList || !dom.uploadArea) return;
      dom.fileList.innerHTML = "";

      if (uploadedFiles.length === 0) {
        dom.uploadArea.classList.add("hidden");
        return;
      }
      dom.uploadArea.classList.remove("hidden");

      uploadedFiles.forEach((fileInfo) => {
        const li = document.createElement("li");
        li.classList.add(
          "flex",
          "items-center",
          "justify-between",
          "my-1",
          "py-2",
          "border-gray-200",
          "border-b"
        );
        li.dataset.filename = fileInfo.name;

        // // 新增：文件图标容器
        // const iconWrapper = document.createElement("div");
        // iconWrapper.classList.add("flex-shrink-0", "mr-3"); // 获取文件扩展名

        // const fileExtension = fileInfo.name.split(".").pop().toLowerCase(); // 查找对应的图标，如果没有找到则使用默认图标
        // const iconPath = fileIcons[fileExtension] || fileIcons["default"]; // 创建并设置图标元素

        // const iconImg = document.createElement("img");
        // iconImg.src = iconPath;
        // iconImg.alt = `${fileExtension} icon`;
        // iconImg.classList.add("h-6", "w-6", "object-contain");
        // iconWrapper.appendChild(iconImg);
        // li.appendChild(iconWrapper);

        const fileNameSpan = document.createElement("span");
        fileNameSpan.classList.add(
          "text-sm",
          "text-gray-700",
          "truncate",
          "w-full"
        );
        fileNameSpan.textContent = `${fileInfo.name} (${formatBytes(fileInfo.size)})`;
        li.appendChild(fileNameSpan);

        const deleteButton = document.createElement("button");
        deleteButton.type = "button";
        deleteButton.textContent = "❌";
        deleteButton.classList.add(
          "text-red-500",
          "hover:text-red-700",
          "font-medium",
          "ml-4",
          "flex-shrink-0"
        );
        deleteButton.addEventListener("click", () => {
          uploadedFiles = uploadedFiles.filter((f) => f.name !== fileInfo.name);
          renderFileList();
          if (uploadedFiles.length === 0 && dom.fileInput) {
            dom.fileInput.value = "";
          }
        });

        li.appendChild(deleteButton);
        dom.fileList.appendChild(li);
      });
    }

    function handleFileChange() {
      const files = dom.fileInput.files;
      if (!files || files.length === 0) {
        if (uploadedFiles.length === 0) {
          if (dom.fileInput) dom.fileInput.value = "";
        }
        return;
      }

      let hasError = false;
      const newFiles = Array.from(files).filter((file) => {
        if (file.size > MAX_FILE_SIZE) {
          hasError = true;
          return false;
        }
        return true;
      });

      if (hasError) {
        if (dom.errorText)
          dom.errorText.textContent = `部分文件超过 ${MAX_SIZE_MB}MB 大小限制`;
        if (dom.errorMessageContainer)
          dom.errorMessageContainer.classList.remove("hidden");
        if (dom.uploadArea) dom.uploadArea.classList.add("hidden");
        if (dom.fileInput) dom.fileInput.value = "";
      } else {
        if (dom.errorMessageContainer)
          dom.errorMessageContainer.classList.add("hidden");
        uploadedFiles = newFiles;
        renderFileList();
      }
    }
    // --- 创建笔记和弹窗逻辑 ---

    const arrayBufferToBase64 = (buffer) => {
      let binary = "";
      const bytes = new Uint8Array(buffer);
      const len = bytes.byteLength;
      for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return window.btoa(binary);
    };

    async function handleCreateNote() {
      console.log("创建笔记按钮被点击了！");

      const noteContent = dom.noteContentInput.value.trim();
      if (!noteContent && uploadedFiles.length === 0) {
        // ⭐ 修改：允许只上传文件
        alert("笔记内容和附件不能同时为空！");
        return;
      }

      if (!dom.errorMessageContainer.classList.contains("hidden")) {
        alert("请解决文件上传错误后重试。");
        return;
      }

      dom.createNoteButton.disabled = true;

      const notePassword = dom.notePasswordInput.value;
      const deleteAfterReading = dom.deleteAfterReadingCheckbox.checked;

      let expirationTtl;
      if (dom.neverExpiresCheckbox.checked) {
        expirationTtl = null;
      } else {
        switch (selectedExpiration) {
          case "1hour":
            expirationTtl = 60 * 60;
            break;
          case "1day":
            expirationTtl = 24 * 60 * 60;
            break;
          case "1week":
            expirationTtl = 7 * 24 * 60 * 60;
            break;
          case "1month":
            expirationTtl = 30 * 24 * 60 * 60;
            break;
          default:
            expirationTtl = 60 * 60; // 默认1小时
        }
      }

      try {
        // 1. 生成一个用于加密笔记内容的随机密钥 (AES-GCM)
        const cryptoKey = await window.crypto.subtle.generateKey(
          { name: "AES-GCM", length: 256 },
          true,
          ["encrypt", "decrypt"]
        ); // 2. 将密钥导出为可存储的格式（ArrayBuffer）

        const exportedKey = await window.crypto.subtle.exportKey(
          "raw",
          cryptoKey
        ); // 3. 将笔记内容转换为 ArrayBuffer

        const encoder = new TextEncoder();
        const encodedContent = encoder.encode(noteContent); // 4. 生成一个随机的初始化向量 (IV)，注意这里用于笔记内容和密钥

        const iv = window.crypto.getRandomValues(new Uint8Array(12)); // 5. 使用密钥和 IV 加密笔记内容

        const encryptedContent = await window.crypto.subtle.encrypt(
          { name: "AES-GCM", iv: iv },
          cryptoKey,
          encodedContent
        );

        // 6. 将加密后的内容和 IV 转换为 Base64 字符串
        const encryptedContentBase64 = arrayBufferToBase64(encryptedContent);
        const ivBase64 = arrayBufferToBase64(iv);
        let finalKeyBase64 = arrayBufferToBase64(exportedKey);

        // 7. 如果设置了密码，则使用密码加密密钥
        if (notePassword) {
          const passwordKey = await window.crypto.subtle.importKey(
            "raw",
            encoder.encode(notePassword),
            { name: "PBKDF2" },
            false,
            ["deriveKey"]
          );

          const derivedPasswordKey = await window.crypto.subtle.deriveKey(
            {
              name: "PBKDF2",
              salt: iv,
              iterations: 100000,
              hash: "SHA-256",
            },
            passwordKey,
            { name: "AES-GCM", length: 256 },
            true,
            ["encrypt", "decrypt"]
          );

          const encryptedKey = await window.crypto.subtle.encrypt(
            { name: "AES-GCM", iv: iv },
            derivedPasswordKey,
            exportedKey
          );

          finalKeyBase64 = arrayBufferToBase64(encryptedKey);
        } // ⭐ 新增：处理和加密文件

        const encryptedFiles = await Promise.all(
          uploadedFiles.map(async (file) => {
            // 读取文件内容为 ArrayBuffer
            const fileBuffer = await file.arrayBuffer(); // 使用相同的 cryptoKey 和 iv 加密文件内容

            const encryptedFileContent = await window.crypto.subtle.encrypt(
              { name: "AES-GCM", iv: iv },
              cryptoKey,
              fileBuffer
            ); // 将加密后的内容转换为 Base64 字符串以便存储

            const encryptedFileContentBase64 =
              arrayBufferToBase64(encryptedFileContent);

            // 返回加密后的文件对象，包含元数据和内容
            return {
              name: file.name,
              type: file.type,
              size: file.size,
              data: encryptedFileContentBase64, // ⭐ 修改：存储加密后的数据
            };
          })
        ); // 8. 准备发送给后端的数据

        const newNoteId = generateUniqueId();
        const encryptedLink = `${window.location.origin}/note/${newNoteId}`;

        const newNote = {
          id: newNoteId,
          content: encryptedContentBase64,
          key: finalKeyBase64,
          iv: ivBase64,
          expiration: expirationTtl,
          deleteAfterReading: deleteAfterReading,
          hasPassword: !!notePassword,
          files: encryptedFiles, // ⭐ 修复点：将加密后的文件数组添加到 newNote
          createdAt: new Date().toISOString(),
        }; // 发送 POST 请求到 Pages Function

        const response = await fetch("/api/note", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(newNote),
        });

        if (!response.ok) {
          throw new Error(
            `Failed to save note to the backend: ${response.statusText}`
          );
        }

        const result = await response.json();
        console.log("笔记已成功保存到 KV:", result); // 10. 重置表单

        dom.noteContentInput.value = "";
        dom.notePasswordInput.value = "";
        dom.deleteAfterReadingCheckbox.checked = false;
        if (dom.neverExpiresCheckbox) {
          dom.neverExpiresCheckbox.checked = false;
        }
        uploadedFiles = [];
        if (dom.fileInput) dom.fileInput.value = "";
        renderFileList(); // 重置过期时间选择按钮样式

        dom.expirationOptionsContainer
          .querySelectorAll("button")
          .forEach((btn) => {
            btn.classList.remove("bg-sky-500/60", "text-white");
            btn.classList.add(
              "bg-gray-100",
              "text-gray-700",
              "hover:bg-gray-200"
            );
            if (btn.dataset.value === "1hour") {
              btn.classList.add("bg-sky-500/60", "text-white");
              btn.classList.remove(
                "bg-gray-100",
                "text-gray-700",
                "hover:bg-gray-200"
              );
            }
          });
        selectedExpiration = "1hour"; // 11. 重新启用按钮

        dom.createNoteButton.disabled = false; // 12. 更新弹窗内容并显示

        dom.encryptedLinkDisplay.value = encryptedLink;
        if (dom.qrcodeCanvas) {
          dom.qrcodeCanvas
            .getContext("2d")
            .clearRect(0, 0, dom.qrcodeCanvas.width, dom.qrcodeCanvas.height);
          try {
            const QRCodeGeneratorObj = await waitForGlobal("QRCodeGenerator");
            if (typeof QRCodeGeneratorObj.toCanvas === "function") {
              await QRCodeGeneratorObj.toCanvas(
                dom.qrcodeCanvas,
                encryptedLink,
                {
                  width: 128,
                  errorCorrectionLevel: "H",
                }
              );
              if (!dom.qrcodeCanvas.dataset.listenerAdded) {
                dom.qrcodeCanvas.style.cursor = "pointer";
                dom.qrcodeCanvas.addEventListener("click", () => {
                  dom.encryptedLinkDisplay.select();
                  dom.encryptedLinkDisplay.setSelectionRange(0, 99999);
                  navigator.clipboard
                    .writeText(dom.encryptedLinkDisplay.value)
                    .then(() => {
                      dom.copyFeedback.textContent = "二维码链接已复制！";
                      dom.copyFeedback.classList.remove("hidden");
                      setTimeout(() => {
                        dom.copyFeedback.classList.add("hidden");
                        dom.copyFeedback.textContent = "链接已复制！";
                      }, 2000);
                    })
                    .catch((err) => {
                      console.error("通过点击二维码复制失败:", err);
                      alert("复制链接失败，请手动复制。");
                    });
                });
                dom.qrcodeCanvas.dataset.listenerAdded = "true";
              }
            } else {
              if (dom.qrcodeContainer)
                dom.qrcodeContainer.textContent = "二维码生成失败。";
            }
          } catch (error) {
            console.error("二维码库加载或生成失败:", error);
            if (dom.qrcodeContainer)
              dom.qrcodeContainer.textContent = "二维码生成失败。";
            alert("二维码生成失败：" + error.message);
          }
        }

        dom.successModal.classList.remove("hidden");
        void dom.successModal.offsetWidth;
        dom.successModal.classList.add("opacity-100");
        dom.successModalContent.classList.remove("scale-95", "opacity-0");
        dom.successModalContent.classList.add("scale-100", "opacity-100");
      } catch (error) {
        console.error("创建笔记失败:", error);
        alert(`创建笔记失败: ${error.message}`);
      } finally {
        dom.createNoteButton.disabled = false;
      }
    } // --- 事件处理函数 ---

    // ⭐ 新增：处理过期选项和永不过期之间的互斥逻辑
    function handleExpirationChange(event) {
      const isNeverExpires = dom.neverExpiresCheckbox.checked;
      const clickedButton = event.target.closest("button[data-value]");

      if (isNeverExpires && clickedButton) {
        // 如果“永不过期”已选中，点击其他按钮则取消它
        dom.neverExpiresCheckbox.checked = false;
      } else if (isNeverExpires) {
        // 如果“永不过期”已选中，将所有过期按钮设置为非选中状态
        dom.expirationOptionsContainer
          .querySelectorAll("button")
          .forEach((btn) => {
            btn.classList.remove("bg-sky-500/60", "text-white");
            btn.classList.add(
              "bg-gray-100",
              "text-gray-700",
              "hover:bg-gray-200"
            );
          });
      }

      // 如果点击了过期时间按钮
      if (clickedButton) {
        dom.expirationOptionsContainer
          .querySelectorAll("button")
          .forEach((btn) => {
            btn.classList.remove("bg-sky-500/60", "text-white");
            btn.classList.add(
              "bg-gray-100",
              "text-gray-700",
              "hover:bg-gray-200"
            );
          });
        clickedButton.classList.add("bg-sky-500/60", "text-white");
        clickedButton.classList.remove(
          "bg-gray-100",
          "text-gray-700",
          "hover:bg-gray-200"
        );
        selectedExpiration = clickedButton.dataset.value;
        // 选中过期时间后，取消“永不过期”和“阅后即焚”
        dom.neverExpiresCheckbox.checked = false;
        dom.deleteAfterReadingCheckbox.checked = false;
      }

      // 无论何种情况，确保“阅后即焚”和“永不过期”是互斥的
      if (
        dom.neverExpiresCheckbox.checked &&
        dom.deleteAfterReadingCheckbox.checked
      ) {
        dom.deleteAfterReadingCheckbox.checked = false;
      }
      if (
        dom.deleteAfterReadingCheckbox.checked &&
        dom.neverExpiresCheckbox.checked
      ) {
        dom.neverExpiresCheckbox.checked = false;
      }
    }

    function handleCopyLink() {
      if (!dom.encryptedLinkDisplay || !dom.copyFeedback) return;
      dom.encryptedLinkDisplay.select();
      dom.encryptedLinkDisplay.setSelectionRange(0, 99999);
      navigator.clipboard
        .writeText(dom.encryptedLinkDisplay.value)
        .then(() => {
          dom.copyFeedback.textContent = "链接已复制！";
          dom.copyFeedback.classList.remove("hidden");
          setTimeout(() => dom.copyFeedback.classList.add("hidden"), 2000);
        })
        .catch((err) => {
          console.error("复制失败:", err);
          alert("复制链接失败，请手动复制。");
        });
    }

    function handleCloseModal() {
      if (!dom.successModal || !dom.successModalContent) return;
      dom.successModal.classList.remove("opacity-100");
      dom.successModalContent.classList.remove("scale-100", "opacity-100");
      dom.successModalContent.classList.add("scale-95", "opacity-0");
      setTimeout(() => dom.successModal.classList.add("hidden"), 300);
    } // --- 初始化函数 ---

    function initEventListeners() {
      // 密码强度和生成
      if (dom.notePasswordInput) {
        dom.notePasswordInput.addEventListener("input", () => {
          const value = dom.notePasswordInput.value;
          if (
            typeof zxcvbn !== "undefined" &&
            dom.passwordStrengthText &&
            dom.passwordStrengthFill
          ) {
            const result = zxcvbn(value);
            dom.passwordStrengthText.textContent = value
              ? `密码强度：${strengthLabels[result.score]}`
              : "";
            strengthColors.forEach((c) =>
              dom.passwordStrengthFill.classList.remove(c)
            );
            if (value) {
              dom.passwordStrengthFill.classList.add(
                strengthColors[result.score]
              );
              dom.passwordStrengthFill.style.width = `${(result.score + 1) * 20}%`;
            } else {
              dom.passwordStrengthFill.style.width = "0%";
            }
          }
        });
        if (dom.notePasswordInput.value) {
          dom.notePasswordInput.dispatchEvent(new Event("input"));
        }
      }
      if (
        dom.togglePasswordButton &&
        dom.notePasswordInput &&
        dom.eyeOpenIcon &&
        dom.eyeClosedIcon
      ) {
        dom.togglePasswordButton.addEventListener("click", () => {
          showPassword = !showPassword;
          dom.notePasswordInput.type = showPassword ? "text" : "password";
          dom.eyeOpenIcon.classList.toggle("hidden", !showPassword);
          dom.eyeClosedIcon.classList.toggle("hidden", showPassword);
        });
      }
      if (dom.generatePasswordButton && dom.notePasswordInput) {
        dom.generatePasswordButton.addEventListener("click", () => {
          const chars =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+";
          let password = "";
          for (let i = 0; i < 15; i++) {
            password += chars.charAt(Math.floor(Math.random() * chars.length));
          }
          dom.notePasswordInput.value = password;
          dom.notePasswordInput.dispatchEvent(
            new Event("input", { bubbles: true, cancelable: true })
          );
        });
      } // 过期时间选择

      if (dom.expirationOptionsContainer) {
        dom.expirationOptionsContainer.addEventListener("click", (event) => {
          const targetButton = event.target.closest("button[data-value]");
          if (targetButton) {
            dom.expirationOptionsContainer
              .querySelectorAll("button")
              .forEach((btn) => {
                btn.classList.remove("bg-sky-500/60", "text-white");
                btn.classList.add(
                  "bg-gray-100",
                  "text-gray-700",
                  "hover:bg-gray-200"
                );
              });
            targetButton.classList.add("bg-sky-500/60", "text-white");
            targetButton.classList.remove(
              "bg-gray-100",
              "text-gray-700",
              "hover:bg-gray-200"
            );
            selectedExpiration = targetButton.dataset.value;

            // ⭐ 新增逻辑：选中过期时间后，取消“永不过期”
            if (dom.neverExpiresCheckbox) {
              dom.neverExpiresCheckbox.checked = false;
            }
          }
        });
      }

      // ⭐ 新增：永不过期选项的事件监听
      if (dom.neverExpiresCheckbox) {
        dom.neverExpiresCheckbox.addEventListener("change", (event) => {
          const isChecked = event.target.checked;
          if (isChecked) {
            // 如果“永不过期”被选中，禁用所有过期时间按钮
            dom.expirationOptionsContainer
              .querySelectorAll("button")
              .forEach((btn) => {
                btn.disabled = true;
                btn.classList.remove("bg-sky-500/60", "text-white");
                btn.classList.add("bg-gray-100", "text-gray-700");
                btn.classList.remove("hover:bg-gray-200");
                btn.classList.add("cursor-not-allowed");
              });
            // 将选中过期时间设置为“永不过期”
            selectedExpiration = "never";

            // ⭐ 互斥逻辑：如果“永不过期”被选中，取消“阅后即焚”
            if (dom.deleteAfterReadingCheckbox) {
              dom.deleteAfterReadingCheckbox.checked = false;
            }
          } else {
            // 如果“永不过期”被取消，启用所有过期时间按钮
            dom.expirationOptionsContainer
              .querySelectorAll("button")
              .forEach((btn) => {
                btn.disabled = false;
                btn.classList.remove("cursor-not-allowed");
                btn.classList.add("hover:bg-gray-200");
              });
            // 重新默认选中1小时
            const oneHourButton = dom.expirationOptionsContainer.querySelector(
              'button[data-value="1h"]'
            );
            if (oneHourButton) {
              oneHourButton.classList.remove(
                "bg-gray-100",
                "text-gray-700",
                "hover:bg-gray-200"
              );
              oneHourButton.classList.add("bg-sky-500/60", "text-white");
              selectedExpiration = "1h";
            }
          }
        });
      }

      // ⭐ 新增：阅后即焚选项的事件监听 (互斥逻辑)
      if (dom.deleteAfterReadingCheckbox) {
        dom.deleteAfterReadingCheckbox.addEventListener("change", (event) => {
          if (event.target.checked) {
            // 如果“阅后即焚”被选中，取消“永不过期”并禁用它
            if (dom.neverExpiresCheckbox) {
              dom.neverExpiresCheckbox.checked = false;
              dom.neverExpiresCheckbox.disabled = true;
              dom.neverExpiresCheckbox
                .closest("label")
                .classList.add("opacity-50");
            }
          } else {
            // 如果“阅后即焚”被取消，启用“永不过期”
            if (dom.neverExpiresCheckbox) {
              dom.neverExpiresCheckbox.disabled = false;
              dom.neverExpiresCheckbox
                .closest("label")
                .classList.remove("opacity-50");
            }
          }
        });
      }

      // 按钮禁用状态和事件
      if (dom.noteContentInput && dom.createNoteButton) {
        const toggleButtonState = () => {
          // ⭐ 修改：在有笔记内容或有文件时启用按钮
          dom.createNoteButton.disabled =
            dom.noteContentInput.value.trim() === "" &&
            uploadedFiles.length === 0;
        };
        dom.noteContentInput.addEventListener("input", toggleButtonState);
        dom.fileInput.addEventListener("change", toggleButtonState); // 监听文件变化
        toggleButtonState();
      }
      if (dom.uploadBtn && dom.fileInput) {
        dom.uploadBtn.addEventListener("click", () => dom.fileInput.click());
        dom.fileInput.addEventListener("change", handleFileChange);
      }
      if (dom.createNoteButton) {
        dom.createNoteButton.addEventListener("click", handleCreateNote);
      }
      if (dom.copyLinkButton) {
        dom.copyLinkButton.addEventListener("click", handleCopyLink);
      }
      if (dom.encryptedLinkDisplay) {
        dom.encryptedLinkDisplay.addEventListener("click", handleCopyLink);
      }
      if (dom.closeModalButton) {
        dom.closeModalButton.addEventListener("click", handleCloseModal);
      }
      if (dom.successModal) {
        dom.successModal.addEventListener("click", (event) => {
          if (event.target === dom.successModal) {
            handleCloseModal();
          }
        });
      }
    } // 页面加载时执行初始化

    document.addEventListener("DOMContentLoaded", initEventListeners);
  }
</script>
